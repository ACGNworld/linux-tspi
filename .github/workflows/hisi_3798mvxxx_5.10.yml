name: Build hisi_3798mvxxx_5.10.bin

on:
  workflow_dispatch:
    inputs:
      target_tag:
        description: 'Source tag to build from'
        required: true
        default: 'hisi3798-v5.10'
      chip_model:
        description: 'Chip model to build for'
        required: true
        default: 'hi3798mv100'
        type: choice
        options:
          - hi3798mv100
          - hi3798mv200
          - hi3798mv300
          - hi3798mv310
          - all

env:
  src_path: /home/runner/work/linux/linux
  modules_path: /home/runner/work/linux/linux/modules/lib/modules

jobs:
  build:
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout source tag
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.target_tag }}
          submodules: true
          fetch-depth: 0
          persist-credentials: false

      - name: Set chip model variables
        run: |
          echo "CHIP_MODEL=${{ github.event.inputs.chip_model }}" >> $GITHUB_ENV
          
          # 定义所有芯片型号的数组
          if [ "${{ github.event.inputs.chip_model }}" = "all" ]; then
            echo "CHIP_MODELS=hi3798mv100 hi3798mv200 hi3798mv300 hi3798mv310" >> $GITHUB_ENV
            echo "BUILD_ALL=true" >> $GITHUB_ENV
          else
            echo "CHIP_MODELS=${{ github.event.inputs.chip_model }}" >> $GITHUB_ENV
            echo "BUILD_ALL=false" >> $GITHUB_ENV
          fi

      - name: Install Latest LZ4
        run: |
          LZ4_LATEST=$(curl -s https://api.github.com/repos/lz4/lz4/releases/latest | grep 'tarball_url' | cut -d\" -f4)
          wget $LZ4_LATEST -O lz4-latest.tar.gz
          tar -xzf lz4-latest.tar.gz
          cd lz4-lz4-*
          make -j$(nproc)
          sudo make install
          sudo ldconfig
          lz4 --version

      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            device-tree-compiler \
            u-boot-tools \
            libssl-dev \
            bc \
            flex \
            bison \
            libncurses-dev \
            initramfs-tools \
            busybox-static \
            libc6-dev-i386 \
            build-essential \
            kmod \
            cpio
          sudo -E apt-get -y install $(curl -fsSL https://tinyurl.com/ubuntu2204-build-armbian)

      - name: Setup ARM Toolchains
        run: |
          # 下载armeb工具链 (用于mv100)
          echo "Downloading ARM toolchain for hi3798mv100..."
          wget https://releases.linaro.org/components/toolchain/binaries/7.5-2019.12/armeb-linux-gnueabi/gcc-linaro-7.5.0-2019.12-x86_64_armeb-linux-gnueabi.tar.xz -O gcc-linaro-7.5.0-2019.12-x86_64_armeb-linux-gnueabi.tar.xz
          
          if [ ! -f "gcc-linaro-7.5.0-2019.12-x86_64_armeb-linux-gnueabi.tar.xz" ]; then
            echo "ARM toolchain download failed, trying alternative source..."
            wget https://snapshots.linaro.org/components/toolchain/binaries/7.5-2019.12/armeb-linux-gnueabi/gcc-linaro-7.5.0-2019.12-x86_64_armeb-linux-gnueabi.tar.xz -O gcc-linaro-7.5.0-2019.12-x86_64_armeb-linux-gnueabi.tar.xz
          fi
          
          tar xf gcc-linaro-7.5.0-2019.12-x86_64_armeb-linux-gnueabi.tar.xz
          echo "ARM_TOOLCHAIN_PATH=$(pwd)/gcc-linaro-7.5.0-2019.12-x86_64_armeb-linux-gnueabi/bin" >> $GITHUB_ENV
          
          # 下载aarch64工具链 (用于mv200/mv300/mv310)
          echo "Downloading AARCH64 toolchain for hi3798mv200/mv300/mv310..."
          wget https://releases.linaro.org/components/toolchain/binaries/7.5-2019.12/aarch64-linux-gnu/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu.tar.xz -O gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu.tar.xz
          
          if [ ! -f "gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu.tar.xz" ]; then
            echo "AARCH64 toolchain download failed, trying alternative source..."
            wget https://snapshots.linaro.org/components/toolchain/binaries/7.5-2019.12/aarch64-linux-gnu/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu.tar.xz -O gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu.tar.xz
          fi
          
          tar xf gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu.tar.xz
          echo "AARCH64_TOOLCHAIN_PATH=$(pwd)/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin" >> $GITHUB_ENV
          
          # 添加到PATH
          echo "$(pwd)/gcc-linaro-7.5.0-2019.12-x86_64_armeb-linux-gnueabi/bin" >> $GITHUB_PATH
          echo "$(pwd)/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin" >> $GITHUB_PATH

      - name: Get Kernel Version
        run: |
          # 首先设置默认架构来获取内核版本
          make ARCH=arm CROSS_COMPILE=${{ env.ARM_TOOLCHAIN_PATH }}/armeb-linux-gnueabi- kernelversion > kernel_version.txt
          echo "kernel_main_version=$(cat kernel_version.txt)" >> $GITHUB_ENV
          echo "Kernel version: ${{ env.kernel_main_version }}"

      - name: Build Kernel for selected models
        run: |
          echo "Building for chip models: ${{ env.CHIP_MODELS }}"
          
          # 创建构建目录
          mkdir -p build_output
          
          # 遍历所有需要构建的芯片型号
          for chip in ${{ env.CHIP_MODELS }}; do
            echo "=========================================="
            echo "Building for $chip"
            echo "=========================================="
            
            DTB_FILE="${chip}.dtb"  # 修复DTB文件名
            DEFCONFIG="${chip}_defconfig"
            
            # 设置架构和工具链
            if [ "$chip" = "hi3798mv100" ]; then
              ARCH="arm"
              CROSS_COMPILE="armeb-linux-gnueabi-"
              TOOLCHAIN_PATH="${{ env.ARM_TOOLCHAIN_PATH }}"
              echo "Using ARM (32-bit) toolchain for $chip"
            else
              ARCH="arm64"
              CROSS_COMPILE="aarch64-linux-gnu-"
              TOOLCHAIN_PATH="${{ env.AARCH64_TOOLCHAIN_PATH }}"
              echo "Using AARCH64 (64-bit) toolchain for $chip"
            fi
            
            # 检查defconfig文件是否存在
            if [ ! -f "arch/${ARCH}/configs/${DEFCONFIG}" ]; then
              echo "Warning: Defconfig file ${DEFCONFIG} not found! Skipping $chip"
              continue
            fi
            
            # 检查dtb文件是否存在
            DTB_PATH="arch/${ARCH}/boot/dts/hisilicon/${DTB_FILE}"
            if [ ! -f "${DTB_PATH}" ]; then
              echo "Warning: DTB file ${DTB_FILE} not found at ${DTB_PATH}! Skipping $chip"
              echo "Available DTB files in arch/${ARCH}/boot/dts/hisilicon/:"
              ls arch/${ARCH}/boot/dts/hisilicon/ | grep -i ${chip} || true
              continue
            fi
            
            # 清理之前的构建
            make ARCH=${ARCH} CROSS_COMPILE=${TOOLCHAIN_PATH}/${CROSS_COMPILE} clean
            
            # 构建内核
            make ARCH=${ARCH} CROSS_COMPILE=${TOOLCHAIN_PATH}/${CROSS_COMPILE} ${DEFCONFIG}
            make ARCH=${ARCH} CROSS_COMPILE=${TOOLCHAIN_PATH}/${CROSS_COMPILE} -j$(nproc)
            
            # 安装模块
            MODULES_DIR="modules_${chip}"
            mkdir -p ${MODULES_DIR}
            make ARCH=${ARCH} CROSS_COMPILE=${TOOLCHAIN_PATH}/${CROSS_COMPILE} modules_install INSTALL_MOD_PATH=${MODULES_DIR}
            
            # 处理内核和dtb合并
            if [ "$ARCH" = "arm" ]; then
              # ARM32位架构：先合并zImage和dtb，然后转换为uImage
              echo "Processing ARM32 architecture for $chip"
              cat arch/arm/boot/zImage ${DTB_PATH} > kernel-dtb-${chip}
              mkimage -A arm -O linux -T kernel -C none -a 0x2000000 -e 0x2000000 -n "Linux-${{ env.kernel_main_version }}-${chip}" -d kernel-dtb-${chip} hi_kernel-${chip}_${{ env.kernel_main_version }}.bin
            else
              # ARM64位架构：先转换Image为uImage，然后与dtb合并
              echo "Processing ARM64 architecture for $chip"
              # 先将Image转换为uImage
              mkimage -A arm64 -O linux -T kernel -C none -a 0x20080000 -e 0x20080000 -n "Linux-${{ env.kernel_main_version }}-${chip}" -d arch/arm64/boot/Image uImage-${chip}
              # 然后将uImage与dtb合并
              cat uImage-${chip} ${DTB_PATH} > hi_kernel-${chip}_${{ env.kernel_main_version }}.bin
            fi
            
            # 打包模块
            cd ${MODULES_DIR}/lib/modules
            tar -zcf ${{ env.kernel_main_version }}-${chip}-modules.tar.gz ${{ env.kernel_main_version }}
            cd ../../..
            
            # 移动文件到输出目录
            mv hi_kernel-${chip}_${{ env.kernel_main_version }}.bin build_output/
            mv ${MODULES_DIR}/lib/modules/${{ env.kernel_main_version }}-${chip}-modules.tar.gz build_output/
            
            # 清理临时文件
            rm -f kernel-dtb-${chip} uImage-${chip}
            
            echo "Completed building for $chip"
          done
          
          # 构建内核头文件
          echo "Building kernel headers..."
          mkdir -p linux-headers-${{ env.kernel_main_version }}
          
          # 复制必要的文件
          cp -a Module.symvers linux-headers-${{ env.kernel_main_version }}/
          cp -a Makefile linux-headers-${{ env.kernel_main_version }}/
          cp -a scripts linux-headers-${{ env.kernel_main_version }}/
          cp -a include linux-headers-${{ env.kernel_main_version }}/
          cp -a .config linux-headers-${{ env.kernel_main_version }}/
          
          # 复制架构相关文件
          if [ -d "arch/arm64" ]; then
            mkdir -p linux-headers-${{ env.kernel_main_version }}/arch/arm64
            cp -a arch/arm64/include linux-headers-${{ env.kernel_main_version }}/arch/arm64/
            cp -a arch/arm64/Makefile linux-headers-${{ env.kernel_main_version }}/arch/arm64/
          fi
          
          if [ -d "arch/arm" ]; then
            mkdir -p linux-headers-${{ env.kernel_main_version }}/arch/arm
            cp -a arch/arm/include linux-headers-${{ env.kernel_main_version }}/arch/arm/
            cp -a arch/arm/Makefile linux-headers-${{ env.kernel_main_version }}/arch/arm/
          fi
          
          tar -zcf build_output/linux-headers-${{ env.kernel_main_version }}.tar.gz linux-headers-${{ env.kernel_main_version }}
          
          # 显示构建结果
          echo "Build completed. Output files:"
          ls -la build_output/

      - name: Upload to Release
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ github.event.inputs.target_tag }}
          name: "Kernel ${{ env.kernel_main_version }} for ${{ env.CHIP_MODEL }}"
          artifacts: "build_output/*"
          body: |
            Tag: ${{ github.event.inputs.target_tag }}
            Kernel version: ${{ env.kernel_main_version }}
            Chip models: ${{ env.CHIP_MODELS }}
            
            Files included:
            - hi_kernel-*.bin: HiSilicon 3798 kernel images for different chip models
            - *-modules.tar.gz: Kernel modules for each chip model
            - linux-headers-*.tar.gz: Kernel headers
          draft: false
          prerelease: false
          allowUpdates: true
          replaceArtifacts: true
